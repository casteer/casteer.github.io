\section{Introduction}

The OpenSCAD design language is a free programmatic design language that has taken hold within the hobbyist community. Like many other programming language, and OpenSCAD is one of the easiest to learn, the user writes a plain-text file which is interpreted by the OpenSCAD compiler to create the object. Once the designer is happy with it, they can export the object's surface as a STL file ready for printing. 

For the Physicist, it gives the opportunity to produce the necessary strcutrue using the few lines of codes; this is true especially for some of the interesting natural structures, such as Fractals, that one might wish to visualize. 

\begin{figure}[h]
 \centering
 \includegraphics[width=0.9\textwidth]{./graphics/openscad_screenshot.png}
 % openscad_screenshot.png: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \caption{A screenshot of the OpenSCAD graphical user interface running under MacOS. The left-hand side of the screen gives the script file and the right-hand side gives the 3D visualization of the structure.}
\end{figure}

\subsection{Installation Details}

OpenSCAD is hosted at \url{http://www.openscad.org/} and all installation details are given on this website. Extra OpenSCAD information and help is available at \url{https://en.wikibooks.org/wiki/OpenSCAD_User_Manual}. 

So the roadmap for this chapter is as follows: First let's through the mathematical background that you need to know in order to be able to more complicated structures. Don't worry, OpenSCAD is particularly accessible and you can start to produce printable straight away but the mathematical background is  really needed to produce larger structures in a modular and parametrized manner. 

\subsection{Typical Usage}

Whilst the GUI and OpenSCAD is straightforward, it might help to go through the typical usage. This is along these lines: First you write your code describing your structure, probably rendering it a few times as you iterate the design\sidenote{The OpenSCAD GUI has two modes to render designs: using the OpenCSG (preview) or CGAL (render) engines. The preview rendering mode is operated by presssing F5, or go through the Design-Preview menu option, and the rendering mode by F6 or through the Design-Render menu option.}


\section{Geometric and Mathematical Background Summary}
\label{sn:mathematical}

\emph{In many design cases it is possible to use trial-and-error to place one part relative to another, for instance. However, trying to do this for many parts, when exploiting the programmatic nature of OpenSCAD, becomes tedious or impractical\sidenote{Alternatively in GUI-based CAD programs, they use the concept of constraints which, for example, can ensure two parts of the design touch each other at a particular point or that two surfaces lie perpendicular to each other.} So here background mathematical information is given in order for the reader to be able to write OpenSCAD code that expresses the required transformation}. 

This section is intended as a reminder of the mathematical background needed to be able to perform supporting calculations for AM design. It's not intended to replace a good textbook on vectors and mathematical geometry and the interested reader is referred to some of the textbooks in the further reading section of this chapter. 

We summarise the main points from mathematical geomtry below: 

\begin{itemize} 
\item Vectors are the mathematical representation of pointing to a location or a translation and are written as $\textbf{v} = \left( v_{1}, v_{2}, v_{3} \right)$, where the $v_{i}$ (i = 1,2,3) are called the components of the vector. In this instance, the vector has three components and represents a location in 3D space.
\item The distance to the 3D point is given by $d = \sqrt{ v_{1}^{2} + v_{2}^{2} + v_{3}^{2} }$, where $d$ is the distance to the 3D point
\item Unit vectors are special vectors whose distances are equal to 1, and typically represent pure directions. These are indicated by $\hat{\textbf{u}}$. 
\item The cosine of the angle between two unit vectors and another $\hat{\textbf{u}} = \left( u_{1}, u_{2}, u_{3} \right)$ is given by the dot product, where each component of the vectors is multiplied together:  $ \cos \theta_{uv} = \textbf{u}.\textbf{v} = u_{1}v_{1} + u_{2}v_{2} + u_{3}v_{3}$. 
\end{itemize}

Rotation and translation operations are given by the multiplication of a set of 3D points by a matrix. A rotation operation depends on the axis of rotation and angle $\theta$. For the perpendicular x,y, and z basis vectors directions, this is given by 
\begin{equation}
 \textbf{R}_{x} \left( \theta \right)= \begin{pmatrix} 1 & 0 & 0 \\ 0 & \cos \theta & \sin \theta \\ 0 & -\sin \theta & \cos\theta \end{pmatrix} 
\end{equation}
\begin{equation}
 \textbf{R}_{y} \left( \theta \right) = \begin{pmatrix} \cos \theta & 0 & \sin \theta \\ 0 & 1 & 0 \\ -\sin \theta & 0 & \cos\theta \end{pmatrix} 
\end{equation}
\begin{equation}
 \textbf{R}_{z} \left( \theta \right) = \begin{pmatrix} \cos \theta & \sin \theta & 0 \\  -\sin \theta & \cos\theta & 0 \\  0 & 0 & 1  \end{pmatrix} 
\end{equation}

These transformation operations can be applied one after another. For example, $\textbf{R}_{y} \left( 30^{\circ} \right)\textbf{R}_{z} \left( 20^{\circ} \right)$ corresponds to a rotation about the z-axis by 20$^{\circ}$ and then about the y-axis by 30$^{\circ}$. It's important to know that the order of the transformations matter. 

% The equation of a flat plane can be represented by a vector $\textbf{x}$ from the origin to any point on the plane, the plane's normal direction $\hat{\textbf{n}}$ and the distance from the origin to the plane (let's call this $d$). The equation of the plane is then $\hat{\textbf{n}}\cdot \textbf{x} = d$. 

\subsection{Transformations and OpenSCAD Recipes : Why is all this mathematics useful?}

There are a number of important recipes for the types of activities that are common to the Physicist/Designer: 

\textbf{1. Rotation about an arbitrary axis: } Really this is a generalisation of the above rotation matrices for any axis. When the axis is given by the unit vector $\hat{\textbf{u}}$, then the rotation is given by 
\begin{equation}
 R_{u} \left(\theta \right) = \cos \left( \theta \right) \textbf{I} + \sin \left( \theta \right) \left[ \hat{\textbf{u}} \right]_{\times}  + \hat{\textbf{u}} \hat{\textbf{u}}^{T}
 \label{arb_rot_matrix}
\end{equation}
where $\textbf{I} = \begin{pmatrix} 1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \end{pmatrix}$ is the unit matrix, $\left[ \hat{\textbf{u}} \right]_{\times} = \begin{pmatrix} 0 & -u_{z} & u_{y} \\ u_{z} & 0 & -u_{x} \\ -u_{y} & u_{x} & 0 \end{pmatrix}$, and $\hat{\textbf{u}} \hat{\textbf{u}}^{T} = \begin{pmatrix} u_{x}^{2} & u_{x}u_{y} & u_{x}u_{z} \\ u_{x}u_{y} & u_{y}^{2} & u_{y}u_{z} \\ u_{x}u_{z} & u_{y}u_{z} & u_{x}^{2} \end{pmatrix}$. 


Although this looks scary, it's quite simple to implement in the OpenSCAD language:
\begin{verbatim}
 
 rot_angle=60;// The rotation angle in degrees
 rot_axis = [1.0, 2.0, 3.0];// The rotation axis

 rotate(rot_angle, rot_axis)
 cylinder(r=10,h=1,$fn=60);// The object, a cylinder of radius 10 units and height 1 unit, with 60 angular divisions

 \end{verbatim}

\begin{figure}[h]
 \centering
 \includegraphics[width=0.4\textwidth]{./graphics/openscad_rotation_axis_null.png}%
 \hspace{0.1cm}\includegraphics[width=0.4\textwidth]{./graphics/openscad_rotation_axis.png}
 % openscad_rotation_axis.png: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \caption{The effect of the rotation about the arbitrary axis before (left) and after (right) the effect of the operation.}
\end{figure}

An important part of the design process is fitting together two parts. 

\textbf{2. Finding the line joining two parts :} Ok so we are designing something that looks like a bizarre dumbell and we would like to join the two directions. The two flat ends of the dumbell are planes so have equations $\hat{\textbf{n}}_{1} \cdot \textbf{x} = d_{1}$, and $\hat{\textbf{n}}_{2} \cdot \textbf{x} = d_{2}$. The joining line is perpendicular to both normals $\hat{\textbf{n}}_{1}$ and $\hat{\textbf{n}}_{2}$, so it is parallel to their cross-product $\hat{\textbf{n}}_{1} \times \hat{\textbf{n}}_{2}$. 
The equation of the line between the two ends is
\begin{equation}
 \textbf{r} = c_{1} \hat{\textbf{n}}_{1} + c_{2} \hat{\textbf{n}}_{2} + \lambda \left( \hat{\textbf{n}}_{1} \times \hat{\textbf{n}}_{2} \right)
\end{equation}
where $c_{1} = \frac{d_{1} - d_{2} \hat{\textbf{n}}_{1} \cdot \hat{\textbf{n}}_{2} }{1 - \left( \hat{\textbf{n}}_{1} \cdot \hat{\textbf{n}}_{2} \right)^{2} }$ and $c_{2} = \frac{d_{2} - d_{1} \hat{\textbf{n}}_{1} \cdot \hat{\textbf{n}}_{2} }{1 - \left( \hat{\textbf{n}}_{1} \cdot \hat{\textbf{n}}_{2} \right)^{2} }$. 

So here let's say that we have a hex nut which we would like to mate on the outside of a plane. The nut can be succintly represented 
\begin{verbatim}
 
 difference(){
  cylinder(r=10,h=1,$fn=6,center=true);// The object, a cylinder of radius 10 units and height 1 unit, with 60 angular divisions
  cylinder(r=8,h=2,$fn=60,center=true);// The object, a cylinder of radius 10 units and height 1 unit, with 60 angular divisions
 }
 
 \end{verbatim}

And now we have our mating part, the 

\begin{verbatim}

 rotate(25,[1,1,1])// This rotates the part by 25 degrees around the (1,1,1) vector
 translate([0,0,30])// This translates the part by 30 units along the z-axis
 rotate([180,0,0])// This flips the part over 
 difference(){
     
      cylinder(r=10,h=5,$fn=6,center=true);// The object, a cylinder of radius 10 units and height 1 unit, with 6 angular divisions. The centre of the cylinder is centred on the origin.  

      cylinder(r=8,h=10,$fn=60);// The object, a cylinder of radius 10 units and height 1 unit, with 6 angular divisions. This cylinder base is centred on the origin.  

     
 } 
 \end{verbatim}

 Ok, in this example, the normal vector to the nut is along $\hat{\textbf{n}}_{1} = \left( 0, 0, 1 \right)$, which is the default normal direction for cylinders in OpenSCAD. 
 
 Before the operations are applied, the normal for the mating part is also $\hat{\textbf{n}}_{2} = \left( 0, 0, 1 \right)$. Then there is a rotation about the $x$-axis by 180 degrees, this changes the normal to $\hat{\textbf{n}}_{2} = \left( 0, 0, -1 \right)$. Then there is a translation, which leaves the normal unchanged. 
 
 Finally in the chain of operations, there is a rotation about the $\textbf{u} = (1,1,1)$ axis by 25 degrees. We can use the results from equation \ref{arb_rot_matrix} to calculate the rotation matrix of this transformation. To do this first we need to find the matrices $\left[ \hat{\textbf{u}} \right]_{\times}$ and $\hat{\textbf{u}} \hat{\textbf{u}}^{T}$. First we need to normalize the vector $\textbf{u}$ by its length, $\hat{\textbf{u}} = \tfrac{1}{\sqrt{3}} (1,1,1)$, then substitute this in to the matrices: 
 \begin{equation}
    \left[ \hat{\textbf{u}} \right]_{\times} = \frac{1}{\sqrt{3}}  \begin{pmatrix} 0 & -1 & 1 \\ 1 & 0 & -1 \\ -1 & 1 & 0 \end{pmatrix}
 \end{equation}
 and 
\begin{equation}
  \hat{\textbf{u}} \hat{\textbf{u}}^{T} = \frac{1}{3} \begin{pmatrix} 1 & 1 & 1 \\ 1 & 1 & 1 \\ 1 & 1 & 1 \end{pmatrix}. 
\end{equation}
Then putting this all together gives
\begin{equation}
 R_{u} \left(\theta \right) = \cos \left( \theta \right) \begin{pmatrix} 1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \end{pmatrix} + \sin \left( \theta \right) \frac{1}{\sqrt{3}}  \begin{pmatrix} 0 & -1 & 1 \\ 1 & 0 & -1 \\ -1 & 1 & 0 \end{pmatrix}  + \frac{1}{3}\begin{pmatrix} 1 & 1 & 1 \\ 1 & 1 & 1 \\ 1 & 1 & 1 \end{pmatrix} 
\end{equation}


 

 
 Move a part to mate with another


\section{Difference and Union Operations}

One application of 3D printing to the Physics is the production of feedthrough panels, such as from the laboratory to the interior of a light-tight box or when printing an enclosure. Feedthrough panels allow cables, for instance, to pass from the lab bench through into the enclosure where the signal is required. When this is required, you need to know what size of hole. 

\begin{verbatim}
 difference(){
    
 
 }
\end{verbatim}






\section{OpenSCAD Design Exercises}
\label{sn:design_exercises}
\subsection{Basic CSG Shapes}

For these exercises, and firstly, make sure you are able to see the axes in the render window. 

\begin{enumerate}
 \item \textbf{Basic CSG shapes}: Create the following
  \begin{enumerate}
    \item A sphere with a radius of 10 units and 10 angular divisions. 
    \item A sphere with a radius of 30 units and angular divisions every 3 degrees
    \item A cylinder with radius of 10 units, height of 20 units and angular divisions every 6 degrees
    \item Using a cylinder command, a hexagonal-based prism which is 20 units long. 
    \item A cone with a base diameter of 20 units and top diameter of 1 unit. 
    \item A unit cube 
    \item A square-based prism which is 4 units long and 1 by 1 unit in cross-section, oriented with the long axis parallel to the Z-axis. 
    \item A L-shape with a cross-section of 2 units by 2 units, in which one arm is 5 units long and the other is 8 units long
  \end{enumerate}
 \item \textbf{Polyhedra}: Create the following
  \begin{enumerate}
  \item Enumerate, starting from 0, and write down the vertices of a square-based pyramid which is 10 units by 10 units, and 20 units high 
  \item For each face of the square based pyramid, write down the triplet of numbers of each face. 
  \item Using a polyhedra command, and information from the previous two questions, render the square-based pyramid using OpenSCAD. 
  \item Increase the height of the pyramid to 40 units and re-render
  \end{enumerate}
\end{enumerate}

\newpage
\subsection{OpenSCAD Design Exercises : Transformations}

\begin{enumerate}
 \item \textbf{The 'center' option\sidenote{OpenSCAD uses American-English spellings.}: } For the following OpenSCAD code\sidenote{Note that the transformation modifying statement (for example the color or rotation commands) do not have a semi-colon at the end of the line. This indicates to the OpenSCAD engine that these operations apply to the following CSG object (which does end with a semi-colon)}.
 \begin{enumerate}
 \item[ ]
 \begin{quote}
  \begin{verbatim}
    color("blue") 
    cylinder(r=1,h=5,$fn=20, center=true);  
    
    color("red") 
    cylinder(r=1,h=5,$fn=20);// same as center=false
    
    color("cyan") 
    cube([2,3,4], center=true);
    
    color("magenta") 
    cube([2,3,4]);
  \end{verbatim}
 \end{quote}
  \item Try commenting one of these lines out using \/\/ at the start of the line 
  \item Calculate the translation vector between the bases of the red and blue cylinders, and then between the cyan and magenta cubes 
  \item Write an equation for the cylinder's centering translation in terms of the cylinder radius, r, and its height, h. Repeat this in terms of a cuboid's x,y, and z sides of lengths a,b, and c respectively. 
 \end{enumerate}

 \item \textbf{Translations :}\sidenote{For these exercises, make sure you keep the axes visible using the View-Show Axes menu options.}
 \begin{enumerate}
 \item[ ]
 \begin{quote}
  \begin{verbatim}
    translate([2,0,1]) 
    color("red") 
    sphere(r=2,$fn=40);
    
    translate([0,7,7]) 
    color("green") 
    sphere(r=3,$fn=40);
    
    translate([1,0,13]) 
    color("blue") 
    sphere(r=1,$fn=40);
  \end{verbatim}
 \end{quote}
 \item Move the spheres so that they are just touching each other in a line, and record the translation vectors 
 \item Decrease the fn value to 7 for all three spheres and note what happens. Why might this be a problem? 
 \end{enumerate}
 
 \item \textbf{Rotations :} 
 \begin{enumerate}
 \item[ ]
 \begin{quote}
  \begin{verbatim}
    rotate([0,0,0]) 
    translate([sqrt(2)*30,0,0]) 
    color("red") 
    sphere(r=3,$fn=40);
    
    translate([0,30,30]) 
    color("green") 
    sphere(r=3,$fn=40);
 \end{verbatim}
 \end{quote}
 \item Set and record the rotation angles so that the red sphere overlaps the green sphere
 \end{enumerate}
 
 \item \textbf{Scaling :} 
 \begin{enumerate}
 \item[ ]
 \begin{quote}
  \begin{verbatim}
    scale([20,1,3])
    color("red")
    sphere(r=3,$fn=40);
  \end{verbatim}
 \end{quote}
  \item Find the OpenSCAD GUI icon which fits the object in the window
  \item Describe the effect that this scale command has had on the sphere
\end{enumerate}
 
 \item \textbf{Mirror Transformation:} 
 \begin{enumerate}
 \item[ ]
 \begin{quote}
 \begin{verbatim}
    mirror([0,1,0])
    color("red")
    translate([2,0,0])
    cube([4,1,1]);
    
    color("green")
    translate([2,0,0])
    cube([4,1,1]);
    
    rotate([0,0,45]) 
    color([1.0,1,0.4,0.6]) 
    cube([0.01,10,10],center=true);
 \end{verbatim}
 \end{quote}
 \item Note that the color command accepts the vector [r,g,b,a], where [r,g,b] are the red,green,blue values respectively (from 0 to 1) and a is the transparency (from 0 to 1, where 0 is transparent and 1 is opaque). 
 \item Set the mirror comand vector in the first example so that the green cuboid is correctly mirrored by the red cuboid in the yellow mirror
 \item[ ]
 \begin{quote}
 \begin{verbatim}
    color("red") 
    translate([5,5,5]) 
    cube([1,1,1],center=true);
    
    mirror([1,0,0]) 
    color("green") 
    translate([5,5,5]) 
    cube([1,1,1],center=true);
    
    mirror([0,1,0]) 
    color("blue") 
    translate([5,5,5]) 
    cube([1,1,1],center=true);
    
    mirror([0,0,1]) 
    color("magenta") 
    translate([5,5,5]) 
    cube([1,1,1],center=true);
 \end{verbatim}
 \end{quote}
 \item In the second example, add mirror commands for the given cubes to give one cube in every octant
 \end{enumerate}

 \item \textbf{Arbitrary Transformations:} Arbitrary transformations are also possible by using the multmatrix, which multiplies all points on the surface of the object by a 4x4 matrix. It is a convenient way of representing translations as well as other transformations, by adding a fourth element with the value 1 to the 3D point to be transformed. For example, the following 4x4 matrix is simply a translation:
 \begin{eqnarray}
  \begin{pmatrix} x_{2} \\ y_{2} \\ z_{2} \\ 1 \end{pmatrix} & = &  \begin{pmatrix} 1 & 0 & 0 & t_{1} \\ 0 & 1 & 0 & t_{2} \\ 0 & 0 & 1 & t_{3} \\0 & 0 & 0 & 0 \end{pmatrix} \begin{pmatrix} x_{1} \\ y_{1} \\ z_{1} \\ 1 \end{pmatrix} \\
  & = &  \begin{pmatrix} x_{1} + t_{1} \\ y_{1} + t_{2} \\ z_{1} + t_{3} \\ 1 \end{pmatrix} 
\end{eqnarray}

\begin{enumerate}
 \item This exercise concerns equivalent transformations and also shows the use of variables in OpenSCAD scripts 
 \begin{quote}
 \begin{verbatim}
	angle=20;// degrees
	M = [ [A, B, 0, 0],[C, D, 0, 0],[0, 0, 1, 0]];
	
	color("red") 
	multmatrix(M) 
	cube(10,center=true);
	
	rotate([0,0,angle]) 
	color("green") 
	cube([5, 5, 20],center=true);
 \end{verbatim}
\end{quote}
\item Calculate and replace A,B,C, and D with sin and cos functions that correctly transform the red cube so that it's sides are parallel with the green cube. Comment on the top left 3x3 matrix within the matrix M. 
 \begin{quote}
 \begin{verbatim}
    M1 = [	
		[ 1, 0.6, 0.0, 20 ], 
		[ 0, 1,   0.7, 0  ],
		[ 0, 0,   1,   0  ],
		[ 0, 0,   0,   1  ] 
	 ] ;
    
    color("red") 
    multmatrix(M1) 
    cube(10,center=true);
    
    M2 = [ 	
		[ 1, 0, 0, 20 ], 
		[ 0, 1, 0, 0  ],  
		[ 0, 0, 1, 0  ],
		[ 0, 0, 0, 1  ] 
	 ] ;
    color("red") 
    multmatrix(M2) 
    cube(10,center=true);
 \end{verbatim}
\end{quote}
\item Describe the two matrix operations M1 and M2 and how they transform the cube
\item Create a cone with base radius 10 units and rotate this object by 60 degrees about the axis $\left(1,1,1\right)$.
 \end{enumerate}


 
 \end{enumerate}% End of transformations section 
 
\newpage
\subsection{OpenSCAD Design Exercises : Special Transformations}


\begin{enumerate}
 \item \textbf{Minkowski Sum: } The Minkowski sum is the object equivalent to the convolution of one object with another, and is a good way to produce curved edges on parts. It is computationally expensive so if you'd like to use this operation then expect to wait a short while on less capable computers. 
 \begin{enumerate}
 \item[ ]
 \begin{quote}
 \begin{verbatim}
 
 translate([-20,0,0])
 cube([10,10,1],center=true); // Object 1
 
 translate([0,0,0])
 sphere(3,$fn=6,center=true); // Object 2
 
 // This translation applies to the whole combined object
 translate([20,0,0])
 minkowski(){
	sphere(3,$fn=6,center=true); // Object 2
	cube([10,10,1],center=true); // Object 1
}

 \end{verbatim}
\end{quote}
\item Using a Minkowski sum operation, create a box and lid whose edges are nicely curved. 
\end{enumerate}
\item \textbf{Convex Hull: }
\begin{enumerate}
 \item[ ]
 \begin{quote}
 \begin{verbatim}
translate([-40,0,0])// This translation applies to object 1
color("blue") 
sphere(10,$fn=32,center=true); // Object 1 on its own

translate([-20,0,0])// This translation applies to object 2
color("red") 
cylinder(r=5,h=10,$fn=16,center=true); // Object 2 on its own

translate([0,0,10])
color("blue") 
sphere(10,$fn=32,center=true); // Object 1 translate along Z by 10 units

color("red") 
cylinder(r=5,h=10,$fn=16,center=true); // Object 2 at the origin

// This translation applies to the whole combined object
color("magenta") 
translate([20,0,0])
hull(){
	translate([0,0,10])
	sphere(10,$fn=32,center=true); // Object 1
	cylinder(r=5,h=10,$fn=16,center=true); // Object 2 on its own
	cube([10,10,1],center=true); // Object 1
}
 \end{verbatim}
\end{quote}
\item Describe what is meant by convexity of a set of points 
\item Describe a feature of a design where and why you might want to use this operation. 
 \end{enumerate}
\end{enumerate}





\newpage
\subsection{OpenSCAD Design Exercises : To practise and for fun! }

\begin{itemize}
 \item Write your name's initials using only cylinders, translate and rotate commands 
 \item Design an enclosure for an Arduino Uno (you'll need the board dimensions which are here: \url{https://www.flickr.com/photos/johngineer/5484250200/sizes/o/in/photostream/}) 
 \item Create a flat 8x8 checkerboard of colored squares, and then pieces in a stylised gometric manner (have look at this \url{http://www.thingiverse.com/search/page:1?q=chess+pieces&sa=} for inspiration!)
\end{itemize}

\newpage
\section{Further Reading}

\begin{itemize}
 \item Functional Design for 3D Printing : Designing 3D printed things for everyday use, by Clifford T Smyth. 
\end{itemize}


\section{Appendix 1 : OpenSCAD CheatSheet}%

\begin{fullwidth}
  \parbox[c][\textwidth][s]{\textheight}{%
  \includegraphics[width=2\textwidth, keepaspectratio, trim=10 250 10 10,clip=true]{./graphics/OpenSCAD_CheatSheet.pdf}
  \captionof{figure}{A reproduction of the OpenSCAD cheat sheet, giving details of the majority of commands used.}
} 
\end{fullwidth}

